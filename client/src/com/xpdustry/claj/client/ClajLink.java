package com.xpdustry.claj.client;

import java.net.URI;

import arc.util.serialization.Base64Coder;


/**
 * CLaJ links (for this version) are URI, and formatted like that: {@code claj://host:port/room-id} 
 * or {@code host:port/room-id}.<br>
 * - {@code 'claj://'} is the protocol name (this part is optional). <br>
 * - {@code 'host'} is the host server. <br>
 * - {@code 'port'} is the server port to connect to. <br>
 * - {@code 'room-id'} is a base64 (url safe) encoded {@code long}, generated by the server and 
 * given to the client that created the room.
 * 
 * @implNote parsing without protocol scheme doesn't works.
 */
public class ClajLink {
  public static final String UriScheme = "claj";

  public final URI uri;
  public final String host;
  public final int port;
  public final long roomId;
  public final String encodedRoomId;

  public ClajLink(String host, int port, String roomId) {
    if (host == null || host.isEmpty()) throw new IllegalArgumentException("Missing host");
    if (port == -1) throw new IllegalArgumentException("Missing port");
    if (roomId != null && roomId.startsWith("/")) roomId = roomId.substring(1);
    if (roomId == null || roomId.isEmpty()) throw new IllegalArgumentException("Missing room id");
    
    this.host = host;
    this.port = port;
    try { this.roomId = bytesToLong(Base64Coder.decode(roomId, Base64Coder.urlsafeMap)); }
    catch (Exception e) { throw /*e;*/new IllegalArgumentException("Invalid room id"); }
    this.encodedRoomId = roomId;
    
    try { uri = new URI(UriScheme, null, host, port, '/'+encodedRoomId, null, null); }
    // This error can only happen when the host is invalid
    catch (java.net.URISyntaxException e) { throw new IllegalArgumentException("Invalid host"); }
  }
  
  public ClajLink(String host, int port, long roomId) {
    if (host == null || host.isEmpty()) throw new IllegalArgumentException("Missing host");
    if (port == -1) throw new IllegalArgumentException("Missing port");
    
    this.host = host;
    this.port = port;
    this.roomId = roomId;
    this.encodedRoomId = new String(Base64Coder.encode(longToBytes(roomId), Base64Coder.urlsafeMap));

    try { uri = new URI(UriScheme, null, host, port, '/'+encodedRoomId, null, null); }
    // This error can only happen when the host is invalid
    catch (java.net.URISyntaxException e) { throw new IllegalArgumentException("Invalid host"); }
  }

  @Override
  public String toString() {
    return uri.toString();
  }
  
  /** @throws IllegalArgumentException if the link is invalid */
  public static ClajLink fromString(String link) {
//    if (!link.contains("://") && !link.startsWith(UriScheme+"://")) link = UriScheme+"://"+link;
    if (link.startsWith(UriScheme) && 
        (!link.startsWith(UriScheme+"://") || link.length() == (UriScheme+"://").length())) 
      throw new IllegalArgumentException("Missing host");
    
    URI uri;
    try { uri = URI.create(link); }
    catch (IllegalArgumentException e) { 
      String cause = e.getLocalizedMessage();
      int semicolon = cause.indexOf(':');
      if (semicolon == -1) throw e;
      else throw new IllegalArgumentException(cause.substring(0, semicolon), e);
    };
    
    if (uri.isAbsolute() && !uri.getScheme().equals(UriScheme))
      throw new IllegalArgumentException("Not a CLaJ link");

    return new ClajLink(uri.getHost(), uri.getPort(), uri.getPath());
  }
  
  
  /** Damn, why there are no native way to convert a long to a byte array? */
  private static byte[] longToBytes(long l) {
    byte[] result = new byte[Long.BYTES];
    for (int i=Long.BYTES-1; i>=0; i--) {
        result[i] = (byte)(l & 0xFF);
        l >>= 8;
    }
    return result;
  }
  
  /** Damn, why there are no native way to convert a bytes array to a long? */
  private static long bytesToLong(final byte[] b) {
    if (b.length != Long.BYTES) throw new IndexOutOfBoundsException("must be " + Long.BYTES + " bytes");
    long result = 0;
    for (int i=0; i<Long.BYTES; i++) {
        result <<= 8;
        result |= (b[i] & 0xFF);
    }
    return result;
  }
}
